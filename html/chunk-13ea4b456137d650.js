class n{_;u;y;texture=null;width=0;height=0;constructor(_,u,y={}){this.app=_;this.url=u;this.config=y}setImage(_,u,y){return this.texture=_,this.width=u,this.height=y,this}async loadImage(){if(this.url==="manual"){if(this.texture===null)throw new Error("manual specified, but texture was not ready...");return}if(this.texture!==null)return;this.app.telemetry?.addTextures(-1),this.app.loading("Fetching textures...");const _=new Image;return new Promise((u,y)=>{_.onload=async()=>{this.texture=await createImageBitmap(_,{imageOrientation:"flipY"}),this.width=this.texture.width,this.height=this.texture.height,this.app.telemetry?.addTextures(2),u(void 0)},_.onerror=(f)=>{this.app.telemetry?.addTextures(1),y(new Error(`texture load of ${this.url} failed: ${f.toString()}`))},_.src=this.url})}}var q=`#version 300 es
uniform mat4 u_view;uniform mat4 u_projection;uniform mat4 u_object_to_world;uniform mat4 u_object_to_world_inv;uniform vec3 u_light_0;in vec4 a_vertex;in vec2 a_uv0;in vec3 a_normal;in vec4 a_vertex_color;out vec2 uv0;out vec3 normal;out vec4 vertex_color;out vec3 light_pos;
#define ROUNDING_FACTOR 230.0f
void main(){mat4 worldInv=inverse(u_view);mat4 MVW=u_projection*u_view*u_object_to_world;vec4 realPosition=MVW*a_vertex;realPosition.xyz=round(vec3(realPosition.xyz*ROUNDING_FACTOR))/ROUNDING_FACTOR;gl_Position=realPosition;uv0=a_uv0;normal=normalize(mat3(worldInv)*a_normal);vertex_color=a_vertex_color;light_pos=normalize(mat3(u_object_to_world_inv)*u_light_0);}`;
export{n as a,q as b};
